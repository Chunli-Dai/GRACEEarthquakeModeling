	Program plotgr_4inv
! output grid match Dr Guo's grid format in Grid2SHCs.exe bw=450
!       Modification: Chunli Dai, June 2014
!                     SA_graD_flat_bw900.dat generated by this code not from outside
	implicit none
	integer i,j,k,n,nl,bw,err,ik
        double precision dB,dL,lat,lon,gridbg
	double precision,allocatable :: grde(:,:),OF(:,:),uz(:,:)
	character*80 ifile,ofile,string
        character*80 ofile2,ifile2
        double precision sigma,rho_ocean,diff , tmp(9),freeair
        integer id
        double precision g0,rearth
        parameter(g0=9.82d+00,rearth=6.371d+06)

        double precision,allocatable:: gridbgg(:,:),sigmag(:,:)

      REAL*8, PARAMETER :: UNDEF =1d8
!     REAL*8, PARAMETER :: DX =1d0/60d0, DY =-DX
      REAL*8  DX, DY 
      REAL*8   DXMIN , DYMIN
      INTEGER*4, PARAMETER :: HLEN =3, VLEN =3
      REAL*4 elev(HLEN,VLEN)
      REAL*8 psx, psy
      REAL*8 h,hreal
      Real*8 PI,D2R
      integer m
      real*8 x,y
      character topofile*80
      real*8 latt,lont,elevt,dBto,dLto
      integer ncols, nrows,i1,i2,i3,j1,j2,j3,idtopo
      real*8 lats,late,lons,lone

      real*8 aa
      real*8  ux,uy,lataf,lonaf,haf,hbar,sigma_topoh,sigma_sum
      real*8 rho_crust
      character*80 ofile3,ofile4
      integer nt

      aa=6371.d3  !Earth mean radius!in meter
      PI=DATAN(1D0)*4D0
      D2R=PI/180D0; 
        
        write(*,*)'Input rho_crust:'
        read(*,*)rho_crust
!       rho_crust=2000d0;!kg/m^3   !Value in crustWei, check psgrn08_SAinvFault_240km_crustWei.inp

        topofile='etopo1_JPfmt.xyz'

        open(11,file=topofile)
        i=0;
        do while(.true.)
          read(11,fmt='(a80)',iostat=err)string
          if(err.lt.0)exit
          i=i+1
        end do
        nt=i
        read(string,*)late,lone,elevt
        write(*,*)'Number of lines for ',topofile,' is:',nt
        rewind(11)
        read(11,fmt=*)lats,lons,elevt
        read(11,fmt=*)latt,lont,elevt
        close(11)
        DX=anint((lont-lons)*60)/60d0
        write(*,*)'latN latS lonW lonE:',lats,late,lons,lone
        write(*,*)'dx=',anint(DX*60)
        DY=-DX
        dBto=-DY;dLto=dBto
!       lats=60d0;lons=110d0;late=15d0;lone=170d0
!       ncols=3601
!       nrows=2701
!       There might be error for region cross 180E
        nrows=int(anint((lats-late)/dBto+1d0 )) 
        ncols=int(anint((lone-lons)/dLto+1)) 
!       lat=lats-(dble(i)-1d0)*dBto
!       lon=lons+(dble(j)-1d0)*dLto

  ifile2='coseism_4SA_crustWei.dat';

! ofile2='SA_sigma_flat_bw450.dat'; !surface density(*Ocean Function) in kg/m^2;
  ofile='SA_graD_flat_bw900.dat';
  !ofile2='SA_sigma_flat_bw900.dat'
  ofile2='SA_sigma_ocean_flat_bw900.dat'
  !sigma=-dh*rho_ocean*OF
  ofile3='SA_sigma_topoh_flat_bw900.dat'
  !sigma_topoh=rho_crust*hbar-hbar*rho_ocean*OF
  ofile4='SA_sigma_flat_bw900.dat'

  rho_ocean=1020d0; !kg/m^3
! rho_crust=2000d0;!kg/m^3   !Value in crustWei, check psgrn08_SAinvFault_240km_crustWei.inp
! open(1,file=ifile)
  open(1,file=ifile2)
  read(1,fmt='(a80)')string
  n=0
  do while(.true.)
    read(1,fmt='(a80)',iostat=err)string
    if(err.lt.0)exit
    n=n+1
  enddo
  write(*,*)'Input data n:',n
  rewind(1)
! allocate(grde(n,4))
! allocate(grde(n,5))
! allocate(uz(n,5))  !uz: positive downwards; 
  allocate(uz(n,7))  !uz: positive downwards; 
!1:5 Lat[deg] Lon[deg] Uz Geoid in meter, Gravity down in m/s^2
! read(1,fmt='(a80)')string
! do i=1,n
!   read(1,fmt=*,iostat=err)grde(i,:)
! enddo
! close(1)
  nl=n

! Lat[deg]      Lon[deg]          Ux          Uy          Uz         Sxx
! Syy         Szz         Sxy         Syz         Szx          Tx          Ty
! Rot          Gd          Gr
! open(1,file=ifile2)
  read(1,fmt='(a80)')string
  do i=1,n
!   read(1,fmt=*,iostat=err)uz(i,1:2),tmp(1:2),uz(i,3),tmp(1:9),uz(i,4:5)
    read(1,fmt=*,iostat=err)uz(i,1:2),uz(i,6:7),uz(i,3),tmp(1:9),uz(i,4:5)
    if(err.lt.0)Write(*,*)ifile2,' format error!'
  enddo
  close(1)

! bw=450
  bw=900
  dB=180d0/2d0/dble(bw)
  dL=2d0*dB

! Generate empty files first
  open(2,file=ofile)
  open(3,file=ofile2)
  open(8,file=ofile3)
  open(9,file=ofile4)
  do i=1,bw*2
    lat=90.d0-(dble(i)-0.5d0)*dB
    do j=1,bw*2
       lon=(dble(j)-1d0)*dL
       write(2,fmt='(2F10.4,1x,E23.15)')lat,lon,0d0
       write(3,fmt='(2F10.4,1x,E23.15)')lat,lon,0d0
       write(8,fmt='(2F10.4,1x,E23.15)')lat,lon,0d0
       write(9,fmt='(2F10.4,1x,E23.15)')lat,lon,0d0
    enddo !j
  enddo !i
  close(2)
  close(3)
  close(8)
  close(9)
! End of generating empty files, June 2014

  allocate(gridbgg(bw*2,bw*2),sigmag(bw*2,bw*2))
  allocate(OF(bw*2*bw*2,3)) !format: Dr. Guo's GAUSS NOshift

!  ik=1

  open(1,file='OF_bw900_fmt.txt',access="direct",action='read',form="formatted",recl=18,status="old")
  open(2,file=ofile,access="direct",action='write',form="formatted",recl=45,status="old")
  open(3,file=ofile2,access="direct",action='write',form="formatted",recl=45,status="old")
  open(11,file=topofile,access="direct",action='read',form="formatted",recl=52,status="old")
  open(8,file=ofile3,access="direct",action='write',form="formatted",recl=45,status="old")
  open(9,file=ofile4,access="direct",action='write',form="formatted",recl=45,status="old")
  open(12,file='hbar.dat')
  do k=1,nl !
    lat=uz(k,1);lon=uz(k,2)
    i=int(anint((90d0-lat)/dB+0.5d0 ))   !lat=90.d0-(dble(i)-0.5d0)*dB
    j=int(anint(lon/dL+1))  !lon=(dble(j)-1d0)*dL
    lat=90.d0-(dble(i)-0.5d0)*dB
    lon=(dble(j)-1d0)*dL
    id=(i-1)*2*bw+j
    diff=abs(lat-uz(k,1))+abs(lon-uz(k,2))
    if(diff.gt.1d-9)write(*,*)'i, j computed wrong!'

    read(1,fmt='(f6.2,2x,f6.2,2x,f1.0)',rec=id,iostat=err)OF(id,:)
    if(err.lt.0)Write(*,*)'OF format error!'
    diff=abs(lat-OF(id,1))+abs(lon-OF(id,2))
    if(diff.gt.1d-9)write(*,*)'OF format error 2!'
    sigma=uz(k,3)*rho_ocean*OF(id,3) !kg/m^2
!   Use the constant used in Wang's psgrn08-code:2.d0*g0/rearth
    freeair=-2.d0*g0/rearth*1d8*(-uz(k,3)); 
    gridbg=uz(k,5)*1d8-freeair   !m/s^2 -> microGal

!   read(2,fmt="(2F10.4,1x,E23.15)",rec=id,iostat=err)lat,lon,tmp(1)
    write(2,fmt="(2F10.4,1x,E23.15$)",rec=id,iostat=err)lat,lon,gridbg
    write(3,fmt="(2F10.4,1x,E23.15$)",rec=id,iostat=err)lat,lon,sigma

!   Compute hbar, which is equivalent UP by horizontal dispalcements    
    i2=int(anint((lats-lat)/dBto+1d0 )) 
    j2=int(anint((lon-lons)/dLto+1))
    i1=max(i2-1,1);i3=min(i1+2,nrows)
    j1=max(j2-1,1);j3=min(j1+2,ncols)
    dxmin=lons+(dble(j1)-1d0)*dLto
    dymin=lats-(dble(i1)-1d0)*dBto
    elev=0d0
    if((i3-i1).ne.2.or.(j3-j1).ne.2)write(*,*)'Error: elev is not 3 by 3!'
    do i=i1,i3
      y=dymin+dble(i-i1)*dy !lat
      do j=j1,j3
         x=dxmin+dble(j-j1)*dx
         idtopo=(i-1)*ncols+j
         read(11,fmt='(f20.15,2x,f20.15,2x,f7.0)',rec=idtopo,iostat=err)latt,lont,elevt
         if(err.lt.0)Write(*,*)'ETOPO1 data format error!'
         elev(j-j1+1,i-i1+1)=elevt
      enddo
    enddo
   
    psx=lon;psy=lat !elevation positive upward
    CALL blin2(psx,psy,h,elev,HLEN,VLEN,DXMIN,DYMIN,DX,DY,UNDEF)
    
    ux=uz(k,6);uy=uz(k,7) !ux North; uy East in meter
    !Asumme:after earthquake the point at (lonaf,lataf) moved to 
    !location (lon,lat) for about (ux,uy)
    lataf=lat+ (-ux/aa)/D2R
    lonaf=lon+ (-uy/(aa*dsin((90d0-lat)*D2R)))/D2R
    psx=lonaf;psy=lataf
    CALL blin2(psx,psy,haf,elev,HLEN,VLEN,DXMIN,DYMIN,DX,DY,UNDEF)
    hbar=haf-h

    sigma_topoh=rho_crust*hbar-hbar*rho_ocean*OF(id,3) !kg/m^2
    sigma_sum=sigma+sigma_topoh
    write(8,fmt="(2F10.4,1x,E23.15$)",rec=id,iostat=err)lat,lon,sigma_topoh
    write(9,fmt="(2F10.4,1x,E23.15$)",rec=id,iostat=err)lat,lon,sigma_sum

    write(12,fmt="(2F10.4,1x,E23.15)")lat,lon,hbar
    
  enddo
  close(1)

  close(2)
  close(3)
  close(11)
  close(8)
  close(9)
  close(12)

  stop
  end






!-----------------------------------------------------------------------
      SUBROUTINE blin2(x, y, h, grid, mend, nend, xmin, ymin, dx, dy, &
     &                UNDEF)
!-----------------------------------------------------------------------
!
! This program performs bilinear interpolation for a grid data set
!
! Written by Y. Yi  3-12-03 
!
      IMPLICIT NONE
!
      REAL*4 grid(mend, nend)
      REAL *8 x, y, h, xmin, ymin, dx, dy, UNDEF
      REAL *8 xt, dx1, dy1, u1, v1, norm, w(2,2)
      INTEGER *4 mend, nend, m, n, mm, nn, ix, iy
!
! ----------------------------------------------------------------------
      xt = x
      IF (xt <xmin) xt = xt +360
      IF ((xt -xmin)*(xt -(xmin +mend*dx)) >0d0) THEN
        PRINT*, 'X coord. out of interpolation interval'
        h = UNDEF
        RETURN
      ENDIF
      IF ((y -ymin)*(y -(ymin +nend*dy)) >0d0) THEN
        PRINT*, 'Y coord. out of interpolation interval'
        h = UNDEF
        RETURN
      ENDIF
      dx1 = 1/dx
      dy1 = 1/dy
!
! -----< Bilinear interpolation >-----
!
      norm = 0d0
      h    = 0d0

      m = MOD(INT( (xt - xmin)*dx1 ), mend) + 1
      IF (m <1) STOP 'x index'
      n = INT( (y - ymin)*dy1 ) + 1
      IF (n <1 .OR. n >nend) STOP 'y index'
      IF (n ==nend) n = n-1
!
      u1 = MIN((xt - xmin)*dx1 -m +1, 1d0)
      IF (u1 <0d0) STOP 'dx'
      v1 = MIN((y - ymin)*dy1 -n +1, 1d0)
      IF (v1 <0d0) STOP 'dy'
!
      w(1,1) = (1d0 - u1)*(1d0 - v1)
      w(1,2) = (1d0 - u1)*v1
      w(2,1) = u1*(1d0 - v1)
      w(2,2) = u1*v1
!
      DO iy = 1,2
        nn = n + iy - 1
        DO ix = 1,2
          mm = MOD(m + ix - 2, mend) + 1
!          IF (grid(mm,nn)+0d0 /=UNDEF) THEN
            norm = norm +w(ix,iy)
            h    = h    +grid(mm,nn)*w(ix,iy)
!          ENDIF
        ENDDO
      ENDDO

!      IF (norm > 0d0) THEN
        IF (norm /= 1d0) h = h/norm
!      ELSE
!        h = UNDEF
!      ENDIF

      RETURN
      END

